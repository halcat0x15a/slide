!SLIDE

# Scalazプログラミング！

!SLIDE

なにかいいものはないかとScalaのコードを漁っていたのですが、Scalazで書きやすい題材は見つからず・・・

!SLIDE

いろいろなScala関係の書籍を漁ってようやくたどり着いたのが・・・

!SLIDE

*[Real World Haskell](http://www.oreilly.co.jp/books/9784873114231/)*

![Real World Haskell](scalaz/picture_large978-4-87311-423-1.jpeg)

!SLIDE

具体例にJSONライブラリがあるので書いてみましょう。

!SLIDE

# [JSON](http://www.json.org/)データを表現する

```scala
sealed trait JValue

sealed abstract class AbstractJValue[A](value: A) extends NewType[A] with JValue

case class JString(value: String) extends AbstractJValue(value)

case class JNumber(value: Double) extends AbstractJValue(value)

case class JBoolean(value: Boolean) extends AbstractJValue(value)

case object JNull extends JValue

case class JObject(value: (JString, JValue)*) extends AbstractJValue(value)

case class JArray(value: JValue*) extends AbstractJValue(value)
```

!SLIDE

# [NewType](http://scalaz.github.com/scalaz/scalaz-2.9.1-6.0.2/doc/index.html#scalaz.NewType)

既存の型を拡張するものです。

!SLIDE

# NewTypeの定義

```scala
trait NewType[X] {
  val value: X

  override def toString =
    value.toString
}

object NewType {
  implicit def UnwrapNewType[X](n: NewType[X]): X = n.value
}
```

!SLIDE

# NewTypeの例

```scala
scala> case class MyInt(value: Int) extends NewType[Int]
defined class MyInt

scala> 2 + MyInt(1)
res61: Int = 3

scala>
```

!SLIDE

# JSONデータの表示

*JValue*をJSON形式で表示します。

普通は*toString*をオーバーライドしますが、ここでは*Show*を使って実装したいと思います。

!SLIDE

# renderJSON

```scala
lazy val renderJSON: JValue => String = {
  case JNumber(n) => n.shows
  case JString(s) => "\"%s\"".format(s)
  case JBoolean(b) => b.shows
  case JNull => "null"
  case JObject(o @ _*) => o.map(_.fold(renderJSON(_) + ": " + renderJSON(_))).mkString("{", ", ", "}")
  case JArray(a @ _*) => a.map(renderJSON).mkString("[", ", ", "]")
}
```

!SLIDE

**o**の型は(JString, JValue)*

本来Tupleにないはずの*fold*というメソッドを呼び出している。

!SLIDE

# *W

## 拡張するための型

Scalazには*"型名 + W"*という規則で名付けられた型があります。

これはその型を拡張するもので、標準ライブラリにあるものが定義されています。

!SLIDE

# fold

Tupleは*Tuple2W*から*Tuple12W*まで定義されており、そこにfoldが定義されています。

foldはTupleを取り、何らかの値を返す関数を渡します。

!SLIDE

# foldの例

```scala
scala> (1, 2).fold(_ + _)
res116: Int = 3

scala> (1, 2, 3).fold(_ + _ + _)
res117: Int = 6

```

!SLIDE

# Showのインスタンスを作る

```scala
implicit def JValueShow: Show[JValue] = shows(renderJSON)
```

!SLIDE

# *s

## 型クラスを定義するための型

型クラスを定義するには*Equal*の例であったように**new**を使ってインスタンスを作る他に、*"型クラス名 + s"*で定義された関数を使う方法があります。

!SLIDE

# 結果

```scala
scala> JObject(
     |   JString("age") -> JNumber(18),
     |   JString("language") -> JArray(JString("Scala"), JString("Clojure"), JString("Python"))
     | ): JValue
res105: JValue = WrappedArray((age,18.0), (language,WrappedArray(Scala, Clojure, Python)))

scala> res105.shows
res106: String = {"age": 18.0, "language": ["Scala", "Clojure", "Python"]}

```

!SLIDE

表示ができました！
